<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Meet</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/socket.io-client@4"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
        /* Custom styles for the video container and controls */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to the start of the flex container */
            min-height: 100vh;
            padding: 20px; /* Add some padding to the body */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        main {
            width: 100%;
            max-width: 1000px; /* Max width for the main content area */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 25px;
            font-size: 2.5rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .video-container {
            position: relative;
            width: 100%;
            max-width: 800px; /* Limit max width */
            margin: 20px auto; /* Center the container */
            background-color: #000; /* Black background for video area */
            border-radius: 12px; /* Slightly more rounded */
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4); /* Stronger shadow */
            transition: max-width 0.3s ease, margin 0.3s ease, border-radius 0.3s ease;
        }
        .video-container:fullscreen {
            max-width: 100%;
            width: 100%;
            height: 100vh; /* Use full viewport height */
            margin: 0;
            border-radius: 0;
        }
        .video-container video {
            display: block;
            width: 100%;
            height: auto;
            max-height: 100vh;
            object-fit: contain; /* Use contain to prevent stretching in fullscreen */
            transform: scaleX(-1); /* Mirror local video */
        }
        #remoteVideos video {
            transform: scaleX(1); /* Do not mirror remote videos */
        }
        .controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.7); /* Slightly darker, more opaque */
            padding: 15px; /* More padding */
            display: flex;
            flex-wrap: wrap; /* Allow controls to wrap */
            justify-content: center;
            gap: 15px; /* Consistent space between buttons */
            align-items: center;
            transition: opacity 0.3s ease;
            opacity: 1; /* Controls are visible by default */
            z-index: 10; /* Ensure controls are above video */
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .controls button {
            background-color: #5cb85c; /* A nice green for general actions */
            color: white;
            border: none;
            border-radius: 50%; /* Makes the button circular */
            width: 55px; /* Slightly larger buttons */
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px; /* Larger icons */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        /* Specific style for the End Call button */
        #endCall {
            background-color: #ef4444; /* Tailwind red-500 */
        }
        #endCall:hover {
            background-color: #dc2626; /* Tailwind red-600 */
            transform: scale(1.05);
        }
        .controls button:hover {
            background-color: #4cae4c; /* Darker green on hover */
            transform: scale(1.05);
        }
        .controls button:active {
            transform: scale(0.95);
        }
        .controls button i {
            font-size: 20px;
        }
        .controls select {
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #777;
            background-color: rgba(255, 255, 255, 0.1); /* Slightly transparent background */
            color: white;
            font-size: 15px;
            cursor: pointer;
            outline: none; /* Remove outline on focus */
            appearance: none; /* Remove default select arrow */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23ffffff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-6.5%200-12.3%203.2-16.1%208.1-3.9%204.9-4.8%2011.5-2.5%2017.4l137.2%20165.6c4.6%205.5%2011.4%208.6%2018.4%208.6s13.8-3.1%2018.4-8.6L289.4%2085.6c2.3-5.9%201.4-12.5-2.5-17.4z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px top 50%;
            background-size: 12px auto;
        }
        .controls select option {
            background-color: #333; /* Dark background for options */
            color: white;
        }
        .controls select:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
        #remoteVideos {
            display: flex;
            flex-wrap: wrap;
            gap: 20px; /* More space between videos */
            margin-top: 30px; /* More margin */
            justify-content: center; /* Centers the videos horizontally */
        }
        #remoteVideos video {
            width: 360px; /* Larger default size */
            height: 270px;
            border: 3px solid #5cb85c; /* Match button color */
            border-radius: 12px;
            background-color: #111;
            object-fit: cover; /* Use cover for remote videos */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        /* Styles for the chat box */
        .chat-container {
            margin-top: 30px;
            width: 100%;
            max-width: 800px; /* Match video container width */
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: #ffffff;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: none; /* Hidden by default, toggled by button */
        }
        #chatBox {
            flex-grow: 1; /* Allows chat box to take up available space */
            height: 250px; /* Fixed height for chat display area */
            overflow-y: auto; /* Add scroll if content exceeds height */
            padding: 15px;
            border-bottom: 1px solid #eee;
            font-size: 0.95rem; /* Slightly larger font */
            color: #444;
            white-space: pre-wrap; /* Preserve formatting like newlines */
            word-wrap: break-word; /* Break long words */
            line-height: 1.5;
        }
        .chat-input-area {
            display: flex;
            padding: 15px;
            gap: 10px;
            background-color: #f9f9f9;
            border-top: 1px solid #eee;
        }
        #chatInput {
            flex-grow: 1; /* Allows input to take up space */
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s;
        }
        #chatInput:focus {
            border-color: #5cb85c;
        }
        #sendButton {
            padding: 10px 20px;
            background-color: #5cb85c; /* Green button */
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        #sendButton:hover {
            background-color: #4cae4c;
            transform: translateY(-1px);
        }
        #sendButton:active {
            transform: translateY(0);
        }

        /* Styles for File Sharing Area */
        .file-share-container {
            margin-top: 30px;
            width: 100%;
            max-width: 800px; /* Match video container width */
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            background-color: #ffffff;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
            display: none; /* Hidden by default, toggled by button */
        }
        #receivedFiles {
            margin-top: 15px;
            text-align: left;
            font-size: 0.95rem;
            color: #555;
            max-height: 150px; /* Limit height */
            overflow-y: auto; /* Scroll if content exceeds height */
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        #receivedFiles h4 {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        #receivedFiles ul {
            list-style: none;
            padding: 0;
        }
        #receivedFiles li {
            margin-bottom: 8px;
            background-color: #f9f9f9;
            padding: 8px 12px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #receivedFiles li i {
            color: #5cb85c;
            font-size: 1.2rem;
        }
        #receivedFiles a {
            color: #007bff;
            text-decoration: none;
            font-weight: 500;
        }
        #receivedFiles a:hover {
            text-decoration: underline;
        }
        /* Hide the actual file input */
        #fileInput {
            display: none;
        }
        .status-message {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #666;
            background-color: #e6f7ff;
            border-left: 4px solid #2196f3;
            padding: 10px;
            border-radius: 4px;
        }
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .notification {
            background-color: #4CAF50; /* Green for success */
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            opacity: 0;
            animation: fadeInOut 3s forwards;
            min-width: 200px;
            text-align: center;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(20px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            .controls {
                padding: 10px;
                gap: 10px;
            }
            .controls button {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
            .controls select {
                padding: 8px 10px;
                font-size: 13px;
            }
            #remoteVideos video {
                width: 280px;
                height: 210px;
            }
            .chat-container, .file-share-container {
                margin-top: 20px;
                padding: 15px;
            }
            #chatBox {
                height: 180px;
                padding: 10px;
            }
            .chat-input-area {
                padding: 10px;
            }
            #chatInput {
                padding: 8px;
                font-size: 0.9rem;
            }
            #sendButton {
                padding: 8px 15px;
            }
            #receivedFiles li {
                padding: 6px 10px;
            }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans flex flex-col items-center justify-center min-h-screen">
    <main class="container mx-auto px-4 py-8 flex flex-col items-center">
        <h1 class="text-2xl font-bold text-gray-800 mb-6">Live Meeting</h1>
        <div class="video-container" id="videoContainer">
            <video id="localVideo" autoplay muted playsinline></video>
            <div class="controls">
                <button id="toggleMic" title="Toggle Microphone" aria-label="Toggle Microphone">
                    <i class="fas fa-microphone"></i>
                </button>
                <button id="toggleCamera" title="Toggle Camera" aria-label="Toggle Camera">
                    <i class="fas fa-video"></i>
                </button>
                <select id="cameraSelect" title="Select Camera" aria-label="Select Camera">
                    <option value="">Select Camera</option>
                </select>
                <select id="resolutionSelect" title="Select Resolution" aria-label="Select Resolution">
                    <option value="default">Default</option>
                    <option value="640x480">640x480 (VGA)</option>
                    <option value="1280x720">1280x720 (HD)</option>
                    <option value="1920x1080">1920x1080 (Full HD)</option>
                </select>
                <button id="startShare" title="Share Screen" aria-label="Share Screen">
                    <i class="fas fa-desktop"></i>
                </button>
                <button id="toggleChat" title="Toggle Chat" aria-label="Toggle Chat">
                    <i class="fas fa-comment-dots"></i>
                </button>
                <button id="shareFileButton" title="Share File" aria-label="Share File">
                    <i class="fas fa-paperclip"></i>
                </button>
                <button id="toggleFullscreen" title="Toggle Fullscreen" aria-label="Toggle Fullscreen">
                    <i class="fas fa-expand"></i>
                </button>
                <button id="endCall" title="End Call" aria-label="End Call">
                    <i class="fas fa-phone-slash"></i>
                </button>
            </div>
        </div>
        <div id="remoteVideos">
        </div>
        <div class="chat-container">
            <div id="chatBox">
                <p>Welcome to the chat!</p>
            </div>
            <div class="chat-input-area">
                <input type="text" id="chatInput" placeholder="Type your message...">
                <button id="sendButton">Send</button>
            </div>
        </div>
        <div class="file-share-container">
            <button id="selectFileButton" class="btn" aria-label="Select file to share">Select File to Share</button>
            <input type="file" id="fileInput">
            <div id="receivedFiles">
                <h4>Received Files:</h4>
                <ul>
                </ul>
            </div>
            <div id="fileStatus" class="mt-2 text-sm text-gray-600 status-message"></div>
        </div>
    </main>
    <div id="notifications" class="notification-container">
    </div>
    <script>
        // Get references to key HTML elements
        const localVideo = document.getElementById('localVideo');
        const videoContainer = document.getElementById('videoContainer');
        const toggleMicButton = document.getElementById('toggleMic');
        const toggleCameraButton = document.getElementById('toggleCamera');
        const endCallButton = document.getElementById('endCall');
        const startShareButton = document.getElementById('startShare');
        const toggleChatButton = document.getElementById('toggleChat');
        const toggleFullscreenButton = document.getElementById('toggleFullscreen');
        const shareFileButton = document.getElementById('shareFileButton'); // New file share button
        const remoteVideosContainer = document.getElementById('remoteVideos');
        // New camera specific elements
        const cameraSelect = document.getElementById('cameraSelect');
        const resolutionSelect = document.getElementById('resolutionSelect');
        // Chat specific elements
        const chatContainer = document.querySelector('.chat-container');
        const chatBox = document.getElementById('chatBox');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.getElementById('sendButton');
        // File sharing elements
        const fileShareContainer = document.querySelector('.file-share-container');
        const selectFileButton = document.getElementById('selectFileButton'); // Button to trigger file input
        const fileInput = document.getElementById('fileInput'); // Hidden file input
        const receivedFilesList = document.querySelector('#receivedFiles ul'); // List for received files
        const fileStatusDiv = document.getElementById('fileStatus'); // Status area
        const notificationsContainer = document.getElementById('notifications'); // Container for notifications

        // State variables
        let localStream = null;
        let micEnabled = true;
        let cameraEnabled = true; // Initial state for camera
        let sharingEnabled = false; // State for screen sharing
        let peerConnections = {}; // Store RTCPeerConnections, key is peer ID
        let currentCameraDeviceId = null; // Track currently active camera
        let currentRoom = 'defaultRoom'; // A simple room name, could be dynamic

        // Socket.IO instance
        // Connect to the same origin as the HTML is served from
        const socket = io(); 

        // STUN servers help peers discover their public IP and port
        const servers = {
            iceServers: [
                {
                    urls: ['stun:stun.l.google.com:19302', 'stun:stun1.l.google.com:19302']
                },
                // You might add TURN servers here for more complex network scenarios
                // {
                //     urls: 'turn:YOUR_TURN_SERVER_IP:PORT',
                //     username: 'YOUR_USERNAME',
                //     credential: 'YOUR_PASSWORD'
                // }
            ]
        };

        // --- UI Feedback & State Update Functions ---
        function updateMicrophoneIcon() {
            toggleMicButton.querySelector('i').classList.toggle('fa-microphone', micEnabled);
            toggleMicButton.querySelector('i').classList.toggle('fa-microphone-slash', !micEnabled);
        }
        function updateCameraIcon() {
            toggleCameraButton.querySelector('i').classList.toggle('fa-video', cameraEnabled);
            toggleCameraButton.querySelector('i').classList.toggle('fa-video-slash', !cameraEnabled);
        }
        function updateScreenShareIcon() {
            startShareButton.querySelector('i').classList.toggle('fa-desktop', !sharingEnabled);
            startShareButton.querySelector('i').classList.toggle('fa-stop-circle', sharingEnabled); // Use stop icon when sharing
            startShareButton.title = sharingEnabled ? "Stop Sharing" : "Share Screen";
            startShareButton.style.backgroundColor = sharingEnabled ? '#fd7e14' : '#5cb85c'; // Orange when sharing
            startShareButton.style.boxShadow = sharingEnabled ? '0 2px 5px rgba(253, 126, 20, 0.5)' : '0 2px 5px rgba(0, 0, 0, 0.3)';
        }

        function updateMediaControlsState(hasActiveStream) {
            // Disable camera/mic toggles if no local stream is active AND not sharing screen
            toggleMicButton.disabled = !hasActiveStream;
            toggleCameraButton.disabled = !hasActiveStream && !sharingEnabled; // Keep camera toggle enabled if only mic is active, but disable if sharing screen
            cameraSelect.disabled = !hasActiveStream || sharingEnabled; // Disable camera select if no stream or screen sharing
            resolutionSelect.disabled = !hasActiveStream || sharingEnabled; // Disable resolution select if no stream or screen sharing
            startShareButton.disabled = false; // Always allow starting/stopping screen share
            endCallButton.disabled = !hasActiveStream && Object.keys(peerConnections).length === 0; // Disable if no stream and no active peers
        }

        function showNotification(message, type = 'success', duration = 3000) {
            const notificationDiv = document.createElement('div');
            notificationDiv.classList.add('notification');
            if (type === 'error') {
                notificationDiv.style.backgroundColor = '#f44336'; // Red for error
            } else if (type === 'info') {
                notificationDiv.style.backgroundColor = '#2196f3'; // Blue for info
            }
            notificationDiv.textContent = message;
            notificationsContainer.prepend(notificationDiv); // Add to top

            setTimeout(() => {
                notificationDiv.remove();
            }, duration); // Remove after specified duration
        }

        function addChatMessage(message, sender = 'You') {
            const p = document.createElement('p');
            p.textContent = `${sender}: ${message}`;
            chatBox.appendChild(p);
            chatBox.scrollTop = chatBox.scrollHeight; // Scroll to bottom
        }

        // --- CORE WEBRTC/MEDIADEVICE FUNCTIONS ---

        // Function to get/update the local media stream (camera, mic, or screen)
        async function getAndUpdateLocalStream(type = 'camera', deviceId = null, resolution = 'default') {
            console.log(`Attempting to get local stream: Type=${type}, DeviceId=${deviceId}, Resolution=${resolution}`);
            let newStream = null;
            const videoConstraints = {};
            const audioConstraints = true; // Always try to get audio initially

            // Stop existing tracks from the current local stream before requesting new one
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }

            if (type === 'camera') {
                if (deviceId) {
                    videoConstraints.deviceId = { exact: deviceId };
                }
                if (resolution !== 'default') {
                    const [width, height] = resolution.split('x').map(Number);
                    videoConstraints.width = { ideal: width };
                    videoConstraints.height = { ideal: height };
                } else {
                    videoConstraints.width = { ideal: 1280 }; // Default HD
                    videoConstraints.height = { ideal: 720 };
                }
                cameraEnabled = true; // Assume camera is enabled when requesting camera stream
                sharingEnabled = false; // Turn off screen sharing state
                updateScreenShareIcon(); // Update share icon
            } else if (type === 'screen') {
                videoConstraints.width = { ideal: window.innerWidth };
                videoConstraints.height = { ideal: window.innerHeight };
                sharingEnabled = true; // Turn on screen sharing state
                cameraEnabled = false; // Assume camera is off when sharing screen
                updateCameraIcon(); // Update camera icon
            } else {
                console.error("Invalid stream type specified.");
                return;
            }

            try {
                if (type === 'camera') {
                    newStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: audioConstraints });
                } else if (type === 'screen') {
                    // Request screen and optionally system audio
                    newStream = await navigator.mediaDevices.getDisplayMedia({ video: videoConstraints, audio: audioConstraints });
                    const screenVideoTrack = newStream.getVideoTracks()[0];
                    if (screenVideoTrack) {
                        screenVideoTrack.onended = () => {
                            console.log('Screen sharing ended by user/browser.');
                            // Automatically switch back to camera when sharing stops
                            if (sharingEnabled) { // Only trigger if we were actively sharing
                                getAndUpdateLocalStream('camera', currentCameraDeviceId || cameraSelect.value, resolutionSelect.value);
                                sharingEnabled = false; // Reset state
                                updateScreenShareIcon(); // Ensure icon updates
                                showNotification('Screen sharing stopped.', 'info');
                            }
                        };
                    }
                }

                localStream = newStream;
                localVideo.srcObject = localStream;

                // Update current camera device ID only if it's a camera stream
                if (type === 'camera') {
                    currentCameraDeviceId = localStream.getVideoTracks()[0]?.getSettings().deviceId || null;
                    cameraSelect.value = currentCameraDeviceId; // Update select dropdown
                }

                // Initial mute state should be applied to the new stream
                if (localStream.getAudioTracks().length > 0) {
                    localStream.getAudioTracks()[0].enabled = micEnabled;
                }
                if (localStream.getVideoTracks().length > 0) {
                    localStream.getVideoTracks()[0].enabled = cameraEnabled;
                }

                updateCameraList(); // Re-enumerate devices if permissions granted now
                updateMediaControlsState(true);
                updateMicrophoneIcon();
                updateCameraIcon();
                updateScreenShareIcon();

                // Important: Replace tracks in all active peer connections
                for (let peerId in peerConnections) {
                    const pc = peerConnections[peerId];
                    if (pc && pc.connectionState !== 'closed') {
                        // Remove existing tracks from the peer connection that are no longer in the localStream
                        pc.getSenders().forEach(sender => {
                            if (sender.track && !localStream.getTracks().includes(sender.track)) {
                                pc.removeTrack(sender);
                                console.log(`Removed old ${sender.track.kind} track from peer ${peerId}`);
                            }
                        });

                        // Add or replace tracks
                        localStream.getTracks().forEach(newTrack => {
                            let sender = pc.getSenders().find(s => s.track && s.track.kind === newTrack.kind);
                            if (sender) {
                                sender.replaceTrack(newTrack)
                                    .then(() => console.log(`Replaced ${newTrack.kind} track for ${peerId}`))
                                    .catch(e => console.error(`Error replacing track for ${peerId}:`, e));
                            } else {
                                // If a sender for this kind of track doesn't exist, add it
                                pc.addTrack(newTrack, localStream);
                                console.log(`Added new ${newTrack.kind} track to peer ${peerId}`);
                            }
                        });

                        // Renegotiate after track changes
                        negotiateConnection(pc, peerId);
                    }
                }
                console.log('Local stream updated and tracks replaced in peer connections.');
                // Emit event for camera status change
                socket.emit('camera-status', { userId: socket.id, isCameraOn: cameraEnabled, isScreenSharing: sharingEnabled });
                showNotification(`Switched to ${type === 'camera' ? 'camera' : 'screen share'} stream.`, 'info');

            } catch (error) {
                console.error('Error accessing media devices:', error);
                let errorMessage = 'Could not access media devices. Please check permissions.';
                if (error.name === 'NotAllowedError') {
                    errorMessage = 'Access denied. Please grant permission for camera/mic/screen sharing.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = `No suitable device found for ${type} with specified settings.`;
                } else if (error.name === 'OverconstrainedError') {
                    errorMessage = `Constraints could not be satisfied for ${type}: ${error.constraint}`;
                } else if (error.name === 'AbortError') {
                    errorMessage = 'Device selection was cancelled.';
                }
                showNotification(errorMessage, 'error', 5000);
                updateMediaControlsState(false);
                localVideo.srcObject = null;
                localStream = null; // Ensure stream is null on failure
            }
        }

        async function updateCameraList() {
            cameraSelect.innerHTML = '<option value="">Select Camera</option>'; // Clear existing options
            const videoInputDevices = await navigator.mediaDevices.enumerateDevices().then(devices =>
                devices.filter(device => device.kind === 'videoinput')
            ).catch(err => {
                console.error('Error enumerating devices:', err);
                return [];
            });

            if (videoInputDevices.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No cameras found';
                cameraSelect.appendChild(option);
                cameraSelect.disabled = true; // Disable if no cameras
            } else {
                videoInputDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Camera ${cameraSelect.options.length + 1}`; // +1 for user-friendly numbering
                    cameraSelect.appendChild(option);
                });
                cameraSelect.disabled = false; // Enable if cameras are found

                // Select the currently active camera if available
                if (currentCameraDeviceId && Array.from(cameraSelect.options).some(opt => opt.value === currentCameraDeviceId)) {
                    cameraSelect.value = currentCameraDeviceId;
                } else if (localStream && localStream.getVideoTracks().length > 0) {
                    currentCameraDeviceId = localStream.getVideoTracks()[0].getSettings().deviceId;
                    if (Array.from(cameraSelect.options).some(opt => opt.value === currentCameraDeviceId)) {
                        cameraSelect.value = currentCameraDeviceId;
                    }
                } else if (videoInputDevices.length > 0) {
                    // Fallback: select the first camera if no current one is set
                    cameraSelect.value = videoInputDevices[0].deviceId;
                    currentCameraDeviceId = videoInputDevices[0].deviceId;
                }
            }
        }

        // Helper function to create or get a peer connection for a specific peer
        function createPeerConnection(peerId) {
            console.log(`Creating peer connection for ${peerId.substring(0,5)}...`);
            const pc = new RTCPeerConnection(servers);

            // --- DATA CHANNEL SETUP for File Sharing ---
            // Using negotiated: true and id: 0 means both peers create their own channel
            // with the same ID, and they will connect to each other.
            // This avoids the need for ondatachannel event for the initiating peer.
            const fileShareDataChannel = pc.createDataChannel("fileTransferChannel", { ordered: true, negotiated: true, id: 0 });
            fileShareDataChannel.binaryType = 'arraybuffer'; // Crucial for sending binary data

            fileShareDataChannel.onopen = (event) => {
                console.log(`File Transfer Data Channel to ${peerId.substring(0,5)}... opened:`, event);
                showNotification(`File transfer channel opened with ${peerId.substring(0, 5)}...`);
            };
            fileShareDataChannel.onmessage = (event) => {
                // This is the receiving logic for file chunks/metadata
                console.log(`Received Data Channel Message from ${peerId.substring(0,5)}...:`, event.data);
                handleIncomingFileMessage(event.data, peerId);
            };
            fileShareDataChannel.onclose = (event) => {
                console.log(`File Transfer Data Channel to ${peerId.substring(0,5)}... closed:`, event);
                showNotification(`File transfer channel closed with ${peerId.substring(0, 5)}...`, 'info');
            };
            fileShareDataChannel.onerror = (event) => console.error(`File Transfer Data Channel to ${peerId.substring(0,5)}... error:`, event);

            // Store the data channel reference
            pc.fileShareDataChannel = fileShareDataChannel;

            // Event handler for receiving a data channel from the remote peer
            // (This is primarily for non-negotiated data channels or if the remote peer creates a different one)
            pc.ondatachannel = (event) => {
                console.log(`Incoming Data channel from ${peerId.substring(0,5)}...:`, event.channel);
                const receiveChannel = event.channel;
                if (receiveChannel.label === "fileTransferChannel" && receiveChannel.negotiated === false) {
                    // This block would handle if the remote peer created a non-negotiated channel
                    // For this app, we use negotiated channels, so this might not fire for file transfer.
                    receiveChannel.binaryType = 'arraybuffer';
                    let receivedBuffers = [];
                    let receivedFileInfo = null;
                    let receivedBytes = 0;

                    receiveChannel.onopen = () => console.log('Received File Transfer Data Channel opened (non-negotiated).');
                    receiveChannel.onmessage = async (event) => {
                        // Re-use handleIncomingFileMessage
                        handleIncomingFileMessage(event.data, peerId);
                    };
                    receiveChannel.onclose = () => console.log('Received File Transfer Data Channel closed (non-negotiated).');
                    receiveChannel.onerror = (error) => console.error('Received File Transfer Data Channel error (non-negotiated):', error);
                }
            };
            // --- END DATA CHANNEL SETUP ---

            // Event handler for discovering ICE candidates (network information)
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log(`Sending ICE candidate to ${peerId.substring(0,5)}...:`, event.candidate);
                    // Send the candidate to the other peer via the signaling server
                    socket.emit('ice-candidate', {
                        candidate: event.candidate,
                        receiverId: peerId,
                        senderId: socket.id
                    });
                }
            };

            // Event handler for receiving remote tracks from a peer
            pc.ontrack = (event) => {
                console.log(`Received remote track from ${peerId.substring(0,5)}...:`, event.track);
                let remoteVideo = document.getElementById(`remoteVideo-${peerId}`);
                let stream = event.streams[0]; // Get the stream the track belongs to

                if (!remoteVideo) {
                    remoteVideo = document.createElement('video');
                    remoteVideo.id = `remoteVideo-${peerId}`;
                    remoteVideo.autoplay = true;
                    remoteVideo.playsinline = true;
                    remoteVideo.controls = false; // Hide default controls
                    remoteVideo.muted = false; // Don't mute remote videos by default
                    remoteVideosContainer.appendChild(remoteVideo);
                    console.log(`Created new video element for remote peer ${peerId.substring(0,5)}...`);
                }

                // Attach the stream to the video element.
                // If stream is already set, don't reassign unless it's a new stream.
                if (remoteVideo.srcObject !== stream) {
                    remoteVideo.srcObject = stream;
                    console.log(`Assigned new stream to remote video for ${peerId.substring(0,5)}...`);
                }
            };

            // Log connection state changes for debugging
            pc.onconnectionstatechange = (event) => {
                console.log(`Peer connection state for ${peerId.substring(0,5)}...: ${pc.connectionState}`);
                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {
                    // Remove remote video if connection drops
                    const remoteVideo = document.getElementById(`remoteVideo-${peerId}`);
                    if (remoteVideo) {
                        remoteVideo.remove();
                        console.log(`Removed remote video for ${peerId.substring(0,5)}...`);
                        showNotification(`Peer ${peerId.substring(0, 5)}... disconnected.`, 'info');
                    }
                    delete peerConnections[peerId];
                    updateMediaControlsState(localStream !== null && (localStream.getAudioTracks().length > 0 || localStream.getVideoTracks().length > 0)); // Update controls if local stream exists
                }
            };

            pc.oniceconnectionstatechange = () => {
                console.log(`ICE connection state for ${peerId.substring(0,5)}...: ${pc.iceConnectionState}`);
            };

            // Add local stream tracks to the peer connection if available
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                    console.log(`Added local ${track.kind} track to peer connection for ${peerId.substring(0,5)}...`);
                });
            } else {
                console.warn('No local stream available to add to new peer connection.');
            }

            return pc;
        }

        // Handles sending SDP offers for connection initiation or renegotiation
        async function negotiateConnection(pc, peerId) {
            console.log(`Attempting to negotiate with ${peerId.substring(0,5)}...`);
            try {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                socket.emit('offer', {
                    offer: pc.localDescription,
                    receiverId: peerId,
                    senderId: socket.id
                });
                console.log(`Sent offer to ${peerId.substring(0,5)}...`);
            } catch (error) {
                console.error(`Error creating or sending offer to ${peerId.substring(0,5)}...:`, error);
            }
        }

        // Function to handle ending the call
        function endCall() {
            console.log('Ending call...');
            // Stop all local media tracks
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localVideo.srcObject = null;
                localStream = null;
                micEnabled = true; // Reset state
                cameraEnabled = true; // Reset state
                sharingEnabled = false; // Reset state
                updateMicrophoneIcon();
                updateCameraIcon();
                updateScreenShareIcon();
                updateMediaControlsState(false);
            }

            // Close all peer connections
            for (let peerId in peerConnections) {
                if (peerConnections[peerId] && peerConnections[peerId].connectionState !== 'closed') {
                    peerConnections[peerId].close();
                    console.log(`Closed peer connection with ${peerId.substring(0,5)}...`);
                }
            }
            peerConnections = {}; // Clear the object

            // Remove all remote videos
            remoteVideosContainer.innerHTML = '';
            showNotification('Call ended.', 'info');
            socket.emit('end-call'); // Notify server to disconnect from room or other peers
        }


        // --- FILE SHARING LOGIC ---
        const CHUNK_SIZE = 16 * 1024; // 16KB chunks

        async function sendFile(file, peerId) {
            const dataChannel = peerConnections[peerId]?.fileShareDataChannel;
            if (!dataChannel || dataChannel.readyState !== 'open') {
                showNotification(`File transfer channel not open with ${peerId.substring(0, 5)}...`, 'error');
                console.error(`Data channel for ${peerId.substring(0,5)}... is not open.`);
                return;
            }

            fileStatusDiv.textContent = `Sending file: ${file.name} (0%)`;
            showNotification(`Sending file: ${file.name} to ${peerId.substring(0, 5)}...`, 'info');

            // Send metadata first
            const metadata = {
                type: 'file-metadata',
                name: file.name,
                size: file.size,
                fileType: file.type
            };
            dataChannel.send(JSON.stringify(metadata));
            console.log(`Sent file metadata to ${peerId.substring(0,5)}...:`, metadata);

            let offset = 0;
            const fileReader = new FileReader();

            fileReader.onabort = () => console.log('File reading aborted');
            fileReader.onerror = (error) => console.error('File reading error:', error);
            fileReader.onload = (event) => {
                const chunk = event.target.result;
                dataChannel.send(chunk);
                offset += chunk.byteLength;

                const progress = ((offset / file.size) * 100).toFixed(1);
                fileStatusDiv.textContent = `Sending file: ${file.name} (${progress}%)`;

                if (offset < file.size) {
                    readNextChunk();
                } else {
                    // All chunks sent, send end message
                    dataChannel.send(JSON.stringify({ type: 'file-end', name: file.name }));
                    fileStatusDiv.textContent = `File "${file.name}" sent successfully to ${peerId.substring(0, 5)}!`;
                    showNotification(`File "${file.name}" sent!`, 'success');
                    console.log(`File "${file.name}" sent to ${peerId.substring(0,5)}...`);
                }
            };

            const readNextChunk = () => {
                const slice = file.slice(offset, offset + CHUNK_SIZE);
                fileReader.readAsArrayBuffer(slice);
            };

            readNextChunk(); // Start reading the first chunk
        }

        let receivedFileBuffers = new Map(); // Store buffers per peer for concurrent transfers
        let receivedFileInfos = new Map(); // Store file info per peer

        function handleIncomingFileMessage(data, senderId) {
            if (typeof data === 'string') {
                try {
                    const message = JSON.parse(data);
                    if (message.type === 'file-metadata') {
                        receivedFileInfos.set(senderId, {
                            name: message.name,
                            size: message.size,
                            type: message.fileType
                        });
                        receivedFileBuffers.set(senderId, []);
                        fileStatusDiv.textContent = `Receiving file: ${message.name} (0%) from ${senderId.substring(0, 5)}...`;
                        showNotification(`Receiving file: ${message.name} from ${senderId.substring(0, 5)}...`, 'info', 5000);
                        console.log(`Received file metadata from ${senderId.substring(0,5)}...:`, message);
                    } else if (message.type === 'file-end') {
                        const fileInfo = receivedFileInfos.get(senderId);
                        const fileBuffers = receivedFileBuffers.get(senderId);

                        if (fileInfo && fileInfo.name === message.name) {
                            const receivedBlob = new Blob(fileBuffers, { type: fileInfo.type });
                            const downloadUrl = URL.createObjectURL(receivedBlob);

                            const listItem = document.createElement('li');
                            const downloadLink = document.createElement('a');
                            const fileIcon = document.createElement('i');
                            fileIcon.classList.add('fas', 'fa-file-download'); // Download icon

                            downloadLink.href = downloadUrl;
                            downloadLink.textContent = `${fileInfo.name} (${(fileInfo.size / (1024 * 1024)).toFixed(2)} MB)`;
                            downloadLink.download = fileInfo.name; // Suggest filename for download

                            listItem.appendChild(fileIcon);
                            listItem.appendChild(downloadLink);
                            receivedFilesList.appendChild(listItem);

                            fileStatusDiv.textContent = `File "${fileInfo.name}" received successfully from ${senderId.substring(0, 5)}!`;
                            showNotification(`File "${fileInfo.name}" received from ${senderId.substring(0, 5)}!`, 'success', 5000);

                            // Clear for next transfer from this sender
                            receivedFileInfos.delete(senderId);
                            receivedFileBuffers.delete(senderId);
                        } else {
                            console.warn('Received file-end for unknown or mismatched file from', senderId);
                        }
                    }
                } catch (e) {
                    console.warn('Received non-metadata string or malformed JSON on data channel from', senderId, ':', data);
                }
            } else if (data instanceof ArrayBuffer || data instanceof Blob) {
                // This is a file chunk
                let fileInfo = receivedFileInfos.get(senderId);
                let fileBuffers = receivedFileBuffers.get(senderId);

                if (fileInfo && fileBuffers) {
                    fileBuffers.push(data);
                    const receivedBytes = fileBuffers.reduce((sum, buffer) => sum + (buffer.byteLength || buffer.size), 0);
                    const progress = ((receivedBytes / fileInfo.size) * 100).toFixed(1);
                    fileStatusDiv.textContent = `Receiving file: ${fileInfo.name} (${progress}%) from ${senderId.substring(0, 5)}...`;
                } else {
                    console.warn('Received file chunk without prior metadata from', senderId, '. Discarding.');
                }
            }
        }


        // --- Event Listeners for UI Controls ---

        toggleMicButton.addEventListener('click', () => {
            if (localStream && localStream.getAudioTracks().length > 0) {
                micEnabled = !micEnabled;
                localStream.getAudioTracks()[0].enabled = micEnabled;
                updateMicrophoneIcon();
                showNotification(`Microphone ${micEnabled ? 'on' : 'off'}.`, 'info');
                // Notify peers about mic status if needed for their UI
                socket.emit('mic-status', { userId: socket.id, isMicOn: micEnabled });
            } else {
                showNotification('No active audio stream to toggle.', 'error');
            }
        });

        toggleCameraButton.addEventListener('click', () => {
            if (localStream && localStream.getVideoTracks().length > 0) {
                cameraEnabled = !cameraEnabled;
                localStream.getVideoTracks()[0].enabled = cameraEnabled;
                updateCameraIcon();
                showNotification(`Camera ${cameraEnabled ? 'on' : 'off'}.`, 'info');
                // Notify peers about camera status for their UI
                socket.emit('camera-status', { userId: socket.id, isCameraOn: cameraEnabled, isScreenSharing: sharingEnabled });
            } else {
                showNotification('No active video stream to toggle.', 'error');
            }
        });

        cameraSelect.addEventListener('change', async () => {
            const selectedDeviceId = cameraSelect.value;
            if (selectedDeviceId) {
                await getAndUpdateLocalStream('camera', selectedDeviceId, resolutionSelect.value);
            } else {
                showNotification('Please select a camera.', 'info');
            }
        });

        resolutionSelect.addEventListener('change', async () => {
            const selectedResolution = resolutionSelect.value;
            if (localStream && !sharingEnabled) { // Only change resolution if camera is active and not screen sharing
                await getAndUpdateLocalStream('camera', currentCameraDeviceId, selectedResolution);
            } else if (sharingEnabled) {
                showNotification('Cannot change resolution while screen sharing.', 'info');
            } else {
                showNotification('Start your camera first to change resolution.', 'info');
            }
        });

        startShareButton.addEventListener('click', async () => {
            if (sharingEnabled) {
                // If currently sharing, stop sharing and switch back to camera
                await getAndUpdateLocalStream('camera', currentCameraDeviceId || cameraSelect.value, resolutionSelect.value);
                sharingEnabled = false;
            } else {
                // Start screen sharing
                await getAndUpdateLocalStream('screen');
                sharingEnabled = true;
            }
            updateScreenShareIcon(); // Ensure icon is updated after stream change
        });

        endCallButton.addEventListener('click', endCall);

        toggleChatButton.addEventListener('click', () => {
            chatContainer.style.display = chatContainer.style.display === 'none' ? 'flex' : 'none';
            if (chatContainer.style.display === 'flex') {
                chatInput.focus();
                chatBox.scrollTop = chatBox.scrollHeight; // Scroll to bottom when opening
            }
        });

        sendButton.addEventListener('click', () => {
            const message = chatInput.value.trim();
            if (message) {
                addChatMessage(message); // Add to local chatbox
                socket.emit('chat-message', { message, senderId: socket.id }); // Send to server
                chatInput.value = ''; // Clear input
            }
        });

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendButton.click();
            }
        });

        shareFileButton.addEventListener('click', () => {
            fileShareContainer.style.display = fileShareContainer.style.display === 'none' ? 'block' : 'none';
        });

        selectFileButton.addEventListener('click', () => {
            fileInput.click(); // Programmatically click the hidden file input
        });

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                // Filter for connected peers with open data channels
                const activePeerIds = Object.keys(peerConnections).filter(id =>
                    peerConnections[id].connectionState === 'connected' &&
                    peerConnections[id].fileShareDataChannel &&
                    peerConnections[id].fileShareDataChannel.readyState === 'open'
                );

                if (activePeerIds.length === 0) {
                    showNotification('No connected peers with open data channels to send file.', 'error', 4000);
                    fileInput.value = ''; // Clear selected file
                    return;
                }

                if (activePeerIds.length === 1) {
                    sendFile(file, activePeerIds[0]);
                } else {
                    // For simplicity, if multiple peers, send to all with open data channels
                    // In a real app, you'd add a UI to select recipient(s)
                    showNotification('Sending file to all connected peers...', 'info');
                    activePeerIds.forEach(peerId => {
                        sendFile(file, peerId);
                    });
                }
                fileInput.value = ''; // Clear selected file after initiation
            }
        });

        toggleFullscreenButton.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                if (videoContainer.requestFullscreen) {
                    videoContainer.requestFullscreen();
                } else if (videoContainer.mozRequestFullScreen) { /* Firefox */
                    videoContainer.mozRequestFullScreen();
                } else if (videoContainer.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
                    videoContainer.webkitRequestFullscreen();
                } else if (videoContainer.msRequestFullscreen) { /* IE/Edge */
                    videoContainer.msRequestFullscreen();
                }
                toggleFullscreenButton.querySelector('i').classList.replace('fa-expand', 'fa-compress');
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE/Edge */
                    document.msExitFullscreen();
                }
                toggleFullscreenButton.querySelector('i').classList.replace('fa-compress', 'fa-expand');
            }
        });

        // Update fullscreen button icon if user exits fullscreen with ESC key
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                toggleFullscreenButton.querySelector('i').classList.replace('fa-compress', 'fa-expand');
            }
        });

        // --- Socket.IO Event Handlers ---
        socket.on('connect', async () => {
            console.log('Connected to signaling server with ID:', socket.id);
            // Request initial media stream once connected
            await getAndUpdateLocalStream('camera'); // Start with camera stream by default
            socket.emit('join-room', currentRoom);
            updateCameraList(); // Populate camera list once permissions are likely granted
        });

        socket.on('user-connected', async (peerId, peerStatus) => {
            console.log(`User connected: ${peerId.substring(0,5)}...`);
            showNotification(`User ${peerId.substring(0, 5)}... joined the call.`, 'info');

            // Create a new peer connection for the newly connected user
            const pc = createPeerConnection(peerId);
            peerConnections[peerId] = pc;

            // Immediately send an offer to the new peer if we have a local stream
            if (localStream) {
                // Tracks are added in createPeerConnection, no need to re-add here
                await negotiateConnection(pc, peerId);
            }

            // Update remote video status if initial status is provided
            if (peerStatus) {
                const remoteVideo = document.getElementById(`remoteVideo-${peerId}`);
                if (remoteVideo) {
                    remoteVideo.title = `Camera: ${peerStatus.isCameraOn ? 'on' : 'off'}, Screen: ${peerStatus.isScreenSharing ? 'sharing' : 'not sharing'}`;
                }
            }
        });

        socket.on('user-disconnected', (peerId) => {
            console.log(`User disconnected: ${peerId.substring(0,5)}...`);
            showNotification(`User ${peerId.substring(0, 5)}... left the call.`, 'info');
            if (peerConnections[peerId]) {
                peerConnections[peerId].close();
                delete peerConnections[peerId];
            }
            const remoteVideo = document.getElementById(`remoteVideo-${peerId}`);
            if (remoteVideo) {
                remoteVideo.remove();
            }
            updateMediaControlsState(localStream !== null && (localStream.getAudioTracks().length > 0 || localStream.getVideoTracks().length > 0)); // Update controls if local stream exists
        });

        socket.on('offer', async (data) => {
            console.log('Received offer from:', data.senderId.substring(0,5), '...');
            const peerId = data.senderId;
            let pc = peerConnections[peerId];

            if (!pc) {
                pc = createPeerConnection(peerId);
                peerConnections[peerId] = pc;
                // Tracks are added in createPeerConnection, no need to re-add here
            }

            try {
                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                socket.emit('answer', {
                    answer: pc.localDescription,
                    receiverId: peerId,
                    senderId: socket.id
                });
                console.log(`Sent answer to ${peerId.substring(0,5)}...`);
            } catch (error) {
                console.error(`Error setting remote description or creating answer for ${peerId.substring(0,5)}...:`, error);
            }
        });

        socket.on('answer', async (data) => {
            console.log('Received answer from:', data.senderId.substring(0,5), '...');
            const pc = peerConnections[data.senderId];
            if (pc) {
                try {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    console.log(`Set remote description for ${data.senderId.substring(0,5)}...`);
                } catch (error) {
                    console.error(`Error setting remote description for ${data.senderId.substring(0,5)}...:`, error);
                }
            }
        });

        socket.on('ice-candidate', async (data) => {
            console.log('Received ICE candidate from:', data.senderId.substring(0,5), '...');
            const pc = peerConnections[data.senderId];
            if (pc) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                    console.log(`Added ICE candidate for ${data.senderId.substring(0,5)}...`);
                } catch (error) {
                    console.error(`Error adding ICE candidate for ${data.senderId.substring(0,5)}...:`, error);
                }
            }
        });

        socket.on('chat-message', (data) => {
            const senderDisplayName = data.senderId === socket.id ? 'You' : `Peer ${data.senderId.substring(0, 5)}...`;
            addChatMessage(data.message, senderDisplayName);
            // Optionally, show a small notification if chat box is hidden
            if (chatContainer.style.display === 'none') {
                showNotification(`New message from ${data.senderId.substring(0, 5)}...`, 'info', 2000);
            }
        });

        socket.on('camera-status-update', (data) => {
            // Update UI for remote peer's camera status
            console.log(`Peer ${data.userId.substring(0, 5)}... camera status: ${data.isCameraOn}, screen sharing: ${data.isScreenSharing}`);
            const remoteVideo = document.getElementById(`remoteVideo-${data.userId}`);
            if (remoteVideo) {
                remoteVideo.title = `Camera: ${data.isCameraOn ? 'on' : 'off'}, Screen: ${data.isScreenSharing ? 'sharing' : 'not sharing'}`;
                // You could also add a visual indicator overlay on the video element
            }
        });

        socket.on('mic-status-update', (data) => {
            // Update UI for remote peer's mic status
            console.log(`Peer ${data.userId.substring(0, 5)}... mic status: ${data.isMicOn}`);
            const remoteVideo = document.getElementById(`remoteVideo-${data.userId}`);
            if (remoteVideo) {
                // You could add a visual indicator overlay on the video element
            }
        });


        // Initialize media stream and event listeners on page load
        document.addEventListener('DOMContentLoaded', () => {
            updateMediaControlsState(false); // Initial state, nothing active
            // The socket.on('connect') handler will call getAndUpdateLocalStream
        });

    </script>
</body>
</html>