<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Meet</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/socket.io-client@4/dist/socket.io.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
        /* Custom styles for the video container and controls */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to the start of the flex container */
            min-height: 100vh;
            padding: 20px; /* Add some padding to the body */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        main {
            width: 100%;
            max-width: 1000px; /* Max width for the main content area */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 25px;
            font-size: 2.5rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        .video-container {
            position: relative;
            width: 100%;
            max-width: 800px; /* Limit max width */
            margin: 20px auto; /* Center the container */
            background-color: #000; /* Black background for video area */
            border-radius: 12px; /* Slightly more rounded */
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4); /* Stronger shadow */
            transition: max-width 0.3s ease, margin 0.3s ease, border-radius 0.3s ease;
        }
        .video-container:fullscreen {
            max-width: 100%;
            width: 100%;
            height: 100vh; /* Use full viewport height */
            margin: 0;
            border-radius: 0;
        }
        .video-container video {
            display: block;
            width: 100%;
            height: auto;
            max-height: 100vh;
            object-fit: contain; /* Use contain to prevent stretching in fullscreen */
            transform: scaleX(-1); /* Mirror local video */
        }
        #remoteVideos video {
            transform: scaleX(1); /* Do not mirror remote videos */
        }
        .controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.7); /* Slightly darker, more opaque */
            padding: 15px; /* More padding */
            display: flex;
            flex-wrap: wrap; /* Allow controls to wrap */
            justify-content: center;
            gap: 15px; /* Consistent space between buttons */
            align-items: center;
            transition: opacity 0.3s ease;
            opacity: 1; /* Controls are visible by default */
            z-index: 10; /* Ensure controls are above video */
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .controls button {
            background-color: #5cb85c; /* A nice green for general actions */
            color: white;
            border: none;
            border-radius: 50%; /* Makes the button circular */
            width: 55px; /* Slightly larger buttons */
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px; /* Larger icons */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        /* Specific style for the End Call button */
        #endCall {
            background-color: #ef4444; /* Tailwind red-500 */
        }
        #endCall:hover {
            background-color: #dc2626; /* Tailwind red-600 */
            transform: scale(1.05);
        }
        .controls button:hover {
            background-color: #4cae4c; /* Darker green on hover */
            transform: scale(1.05);
        }
        .controls button:active {
            transform: scale(0.95);
        }
        .controls button i {
            font-size: 20px;
        }
        .controls select {
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #777;
            background-color: rgba(255, 255, 255, 0.1); /* Slightly transparent background */
            color: white;
            font-size: 15px;
            cursor: pointer;
            outline: none; /* Remove outline on focus */
            appearance: none; /* Remove default select arrow */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23ffffff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-6.5%200-12.3%203.2-16.1%208.1-3.9%204.9-4.8%2011.5-2.5%2017.4l137.2%20165.6c4.6%205.5%2011.4%208.6%2018.4%208.6s13.8-3.1%2018.4-8.6L289.4%2085.6c2.3-5.9%201.4-12.5-2.5-17.4z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px top 50%;
            background-size: 12px auto;
        }
        .controls select option {
            background-color: #333; /* Dark background for options */
            color: white;
        }
        .controls select:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
        #remoteVideos {
            display: flex;
            flex-wrap: wrap;
            gap: 20px; /* More space between videos */
            margin-top: 30px; /* More margin */
            justify-content: center; /* Centers the videos horizontally */
        }
        #remoteVideos video {
            width: 360px; /* Larger default size */
            height: 270px;
            border: 3px solid #5cb85c; /* Match button color */
            border-radius: 12px;
            background-color: #111;
            object-fit: cover; /* Use cover for remote videos */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        /* Styles for the chat box */
        .chat-container {
            margin-top: 30px;
            width: 100%;
            max-width: 800px; /* Match video container width */
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: #ffffff;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: none; /* Hidden by default, toggled by button */
        }
        #chatBox {
            flex-grow: 1; /* Allows chat box to take up available space */
            height: 250px; /* Fixed height for chat display area */
            overflow-y: auto; /* Add scroll if content exceeds height */
            padding: 15px;
            border-bottom: 1px solid #eee;
            font-size: 0.95rem; /* Slightly larger font */
            color: #444;
            white-space: pre-wrap; /* Preserve formatting like newlines */
            word-wrap: break-word; /* Break long words */
            line-height: 1.5;
        }
        .chat-input-area {
            display: flex;
            padding: 15px;
            gap: 10px;
            background-color: #f9f9f9;
            border-top: 1px solid #eee;
        }
        #chatInput {
            flex-grow: 1; /* Allows input to take up space */
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s;
        }
        #chatInput:focus {
            border-color: #5cb85c;
        }
        #sendButton {
            padding: 10px 20px;
            background-color: #5cb85c; /* Green button */
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        #sendButton:hover {
            background-color: #4cae4c;
            transform: translateY(-1px);
        }
        #sendButton:active {
            transform: translateY(0);
        }
        /* Styles for File Sharing Area */
        .file-share-container {
            margin-top: 30px;
            width: 100%;
            max-width: 800px; /* Match video container width */
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            background-color: #ffffff;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
            display: none; /* Hidden by default, toggled by button */
        }
        #receivedFiles {
            margin-top: 15px;
            text-align: left;
            font-size: 0.95rem;
            color: #555;
            max-height: 150px; /* Limit height */
            overflow-y: auto; /* Scroll if content exceeds height */
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        #receivedFiles h4 {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        #receivedFiles ul {
            list-style: none;
            padding: 0;
        }
        #receivedFiles li {
            margin-bottom: 8px;
            background-color: #f9f9f9;
            padding: 8px 12px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #receivedFiles li i {
            color: #5cb85c;
            font-size: 1.2rem;
        }
        #receivedFiles a {
            color: #007bff;
            text-decoration: none;
            font-weight: 500;
        }
        #receivedFiles a:hover {
            text-decoration: underline;
        }
        /* Hide the actual file input */
        #fileInput {
            display: none;
        }
        .status-message {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #666;
            background-color: #e6f7ff;
            border-left: 4px solid #2196f3;
            padding: 10px;
            border-radius: 4px;
        }
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .notification {
            background-color: #4CAF50; /* Green for success */
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            opacity: 0;
            animation: fadeInOut 3s forwards;
            min-width: 200px;
            text-align: center;
        }
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(20px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            .controls {
                padding: 10px;
                gap: 10px;
            }
            .controls button {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
            .controls select {
                padding: 8px 10px;
                font-size: 13px;
            }
            #remoteVideos video {
                width: 280px;
                height: 210px;
            }
            .chat-container, .file-share-container {
                margin-top: 20px;
                padding: 15px;
            }
            #chatBox {
                height: 180px;
                padding: 10px;
            }
            .chat-input-area {
                padding: 10px;
            }
            #chatInput {
                padding: 8px;
                font-size: 0.9rem;
            }
            #sendButton {
                padding: 8px 15px;
            }
            #receivedFiles li {
                padding: 6px 10px;
            }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans flex flex-col items-center justify-center min-h-screen">
    <main class="container mx-auto px-4 py-8 flex flex-col items-center">
        <h1 class="text-2xl font-bold text-gray-800 mb-6">Live Meeting</h1>
        <div class="video-container" id="videoContainer">
            <video id="localVideo" autoplay muted playsinline></video>
            <div class="controls">
                <button id="toggleMic" title="Toggle Microphone" aria-label="Toggle Microphone">
                    <i class="fas fa-microphone"></i>
                </button>
                <button id="toggleCamera" title="Toggle Camera" aria-label="Toggle Camera">
                    <i class="fas fa-video"></i>
                </button>
                <select id="cameraSelect" title="Select Camera" aria-label="Select Camera">
                    <option value="">Select Camera</option>
                </select>
                <select id="resolutionSelect" title="Select Resolution" aria-label="Select Resolution">
                    <option value="default">Default</option>
                    <option value="640x480">640x480 (VGA)</option>
                    <option value="1280x720">1280x720 (HD)</option>
                    <option value="1920x1080">1920x1080 (Full HD)</option>
                </select>
                <button id="startShare" title="Share Screen" aria-label="Share Screen">
                    <i class="fas fa-desktop"></i>
                </button>
                <button id="toggleChat" title="Toggle Chat" aria-label="Toggle Chat">
                    <i class="fas fa-comment-dots"></i>
                </button>
                <button id="shareFileButton" title="Share File" aria-label="Share File">
                    <i class="fas fa-paperclip"></i>
                </button>
                <button id="toggleFullscreen" title="Toggle Fullscreen" aria-label="Toggle Fullscreen">
                    <i class="fas fa-expand"></i>
                </button>
                <button id="endCall" title="End Call" aria-label="End Call">
                    <i class="fas fa-phone-slash"></i>
                </button>
            </div>
        </div>
        <div id="remoteVideos">
        </div>
        <div class="chat-container">
            <div id="chatBox">
                <p>Welcome to the chat!</p>
            </div>
            <div class="chat-input-area">
                <input type="text" id="chatInput" placeholder="Type your message...">
                <button id="sendButton">Send</button>
            </div>
        </div>
        <div class="file-share-container">
            <button id="selectFileButton" class="btn" aria-label="Select file to share">Select File to Share</button>
            <input type="file" id="fileInput">
            <div id="receivedFiles">
                <h4>Received Files:</h4>
                <ul>
                </ul>
            </div>
            <div id="fileStatus" class="mt-2 text-sm text-gray-600 status-message"></div>
        </div>
    </main>
    <div id="notifications" class="notification-container">
    </div>
    <script>
        // DOM Elements
        const localVideo = document.getElementById('localVideo');
        const remoteVideosContainer = document.getElementById('remoteVideos');
        const toggleMicButton = document.getElementById('toggleMic');
        const toggleCameraButton = document.getElementById('toggleCamera');
        const cameraSelect = document.getElementById('cameraSelect');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const startShareButton = document.getElementById('startShare');
        const toggleChatButton = document.getElementById('toggleChat');
        const shareFileButton = document.getElementById('shareFileButton');
        const toggleFullscreenButton = document.getElementById('toggleFullscreen');
        const endCallButton = document.getElementById('endCall');
        const chatContainer = document.querySelector('.chat-container');
        const chatBox = document.getElementById('chatBox');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.getElementById('sendButton');
        const fileShareContainer = document.querySelector('.file-share-container');
        const selectFileButton = document.getElementById('selectFileButton');
        const fileInput = document.getElementById('fileInput');
        const receivedFilesList = document.querySelector('#receivedFiles ul');
        const fileStatusDiv = document.getElementById('fileStatus');
        const notificationsContainer = document.getElementById('notifications');
        const videoContainer = document.getElementById('videoContainer'); // Added for fullscreen toggling
        // WebRTC Variables
        let localStream;
        let peerConnections = {}; // Stores RTCPeerConnection objects, keyed by peerId
        let dataChannels = {}; // Stores RTCDataChannel objects, keyed by peerId
        let currentCameraDeviceId = null;
        let micEnabled = true;
        let cameraEnabled = true;
        let sharingEnabled = false; // Tracks screen sharing state
        const socket = io(); // Connect to the Socket.IO server
        // WebRTC configuration (STUN servers for NAT traversal)
        const servers = {
            iceServers: [
                {
                    urls: ['stun:stun.l.google.com:19302', 'stun:stun1.l.google.com:19302']
                },
                // You might add TURN servers here for more complex network scenarios
                // {
                //      urls: 'turn:YOUR_TURN_SERVER_IP:PORT',
                //      username: 'YOUR_USERNAME',
                //      credential: 'YOUR_PASSWORD'
                // }
            ]
        };
        // --- UI Feedback & State Update Functions ---
        function updateMicrophoneIcon() {
            toggleMicButton.querySelector('i').classList.toggle('fa-microphone', micEnabled);
            toggleMicButton.querySelector('i').classList.toggle('fa-microphone-slash', !micEnabled);
        }
        function updateCameraIcon() {
            toggleCameraButton.querySelector('i').classList.toggle('fa-video', cameraEnabled);
            toggleCameraButton.querySelector('i').classList.toggle('fa-video-slash', !cameraEnabled);
        }
        function updateScreenShareIcon() {
            startShareButton.querySelector('i').classList.toggle('fa-desktop', !sharingEnabled);
            startShareButton.querySelector('i').classList.toggle('fa-stop-circle', sharingEnabled); // Use stop icon when sharing
            startShareButton.title = sharingEnabled ? "Stop Sharing" : "Share Screen";
            startShareButton.style.backgroundColor = sharingEnabled ? '#fd7e14' : '#5cb85c'; // Orange when sharing
            startShareButton.style.boxShadow = sharingEnabled ? '0 2px 5px rgba(253, 126, 20, 0.5)' : '0 2px 5px rgba(0, 0, 0, 0.3)';
        }
        function updateMediaControlsState(hasActiveStream) {
            // Disable camera/mic toggles if no local stream is active AND not sharing screen
            toggleMicButton.disabled = !hasActiveStream;
            toggleCameraButton.disabled = !hasActiveStream && !sharingEnabled; // Keep camera toggle enabled if only mic is active, but disable if sharing screen
            cameraSelect.disabled = !hasActiveStream || sharingEnabled; // Disable camera select if no stream or screen sharing
            resolutionSelect.disabled = !hasActiveStream || sharingEnabled; // Disable resolution select if no stream or screen sharing
            startShareButton.disabled = false; // Always allow starting/stopping screen share
            endCallButton.disabled = !hasActiveStream && Object.keys(peerConnections).length === 0; // Disable if no stream and no active peers
        }
        function showNotification(message, type = 'success', duration = 3000) {
            const notificationDiv = document.createElement('div');
            notificationDiv.classList.add('notification');
            if (type === 'error') {
                notificationDiv.style.backgroundColor = '#f44336'; // Red for error
            } else if (type === 'info') {
                notificationDiv.style.backgroundColor = '#2196f3'; // Blue for info
            }
            notificationDiv.textContent = message;
            notificationsContainer.prepend(notificationDiv); // Add to top

            setTimeout(() => {
                notificationDiv.remove();
            }, duration); // Remove after specified duration
        }
        function addChatMessage(message, sender = 'You') {
            const p = document.createElement('p');
            p.textContent = `${sender}: ${message}`;
            chatBox.appendChild(p);
            chatBox.scrollTop = chatBox.scrollHeight; // Scroll to bottom
        }
        // --- CORE WEBRTC/MEDIADEVICE FUNCTIONS ---
        // Function to get/update the local media stream (camera, mic, or screen)
        async function getAndUpdateLocalStream(type = 'camera', deviceId = null, resolution = 'default') {
            console.log(`Attempting to get local stream: Type=${type}, DeviceId=${deviceId}, Resolution=${resolution}`);
            let newStream = null;
            const videoConstraints = {};
            const audioConstraints = true; // Always try to get audio initially
            // Stop existing tracks from the current local stream before requesting new one
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (type === 'camera') {
                if (deviceId) {
                    videoConstraints.deviceId = { exact: deviceId };
                }
                if (resolution !== 'default') {
                    const [width, height] = resolution.split('x').map(Number);
                    videoConstraints.width = { ideal: width };
                    videoConstraints.height = { ideal: height };
                } else {
                    videoConstraints.width = { ideal: 1280 }; // Default HD
                    videoConstraints.height = { ideal: 720 };
                }
                cameraEnabled = true; // Assume camera is enabled when requesting camera stream
                sharingEnabled = false; // Turn off screen sharing state
                updateScreenShareIcon(); // Update share icon
            } else if (type === 'screen') {
                videoConstraints.width = { ideal: window.innerWidth };
                videoConstraints.height = { ideal: window.innerHeight };
                sharingEnabled = true; // Turn on screen sharing state
                cameraEnabled = false; // Assume camera is off when sharing screen
                updateCameraIcon(); // Update camera icon
            } else {
                console.error("Invalid stream type specified.");
                return;
            }
            try {
                if (type === 'camera') {
                    newStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: audioConstraints });
                } else if (type === 'screen') {
                    // Request screen and optionally system audio
                    newStream = await navigator.mediaDevices.getDisplayMedia({ video: videoConstraints, audio: audioConstraints });
                    const screenVideoTrack = newStream.getVideoTracks()[0];
                    if (screenVideoTrack) {
                        screenVideoTrack.onended = () => {
                            console.log('Screen sharing ended by user/browser.');
                            // Automatically switch back to camera when sharing stops
                            if (sharingEnabled) { // Only trigger if we were actively sharing
                                getAndUpdateLocalStream('camera', currentCameraDeviceId || cameraSelect.value, resolutionSelect.value);
                                sharingEnabled = false; // Reset state
                                updateScreenShareIcon(); // Ensure icon updates
                                showNotification('Screen sharing stopped.', 'info');
                            }
                        };
                    }
                }
                localStream = newStream;
                localVideo.srcObject = localStream;
                // Update current camera device ID only if it's a camera stream
                if (type === 'camera') {
                    currentCameraDeviceId = localStream.getVideoTracks()[0]?.getSettings().deviceId || null;
                    cameraSelect.value = currentCameraDeviceId; // Update select dropdown
                }
                // Initial mute state should be applied to the new stream
                if (localStream.getAudioTracks().length > 0) {
                    localStream.getAudioTracks()[0].enabled = micEnabled;
                }
                if (localStream.getVideoTracks().length > 0) {
                    localStream.getVideoTracks()[0].enabled = cameraEnabled;
                }
                updateCameraList(); // Re-enumerate devices if permissions granted now
                updateMediaControlsState(true);
                updateMicrophoneIcon();
                updateCameraIcon();
                updateScreenShareIcon();
                // Important: Replace tracks in all active peer connections
                for (let peerId in peerConnections) {
                    const pc = peerConnections[peerId];
                    if (pc && pc.connectionState !== 'closed') {
                        // Remove existing tracks from the peer connection that are no longer in the localStream
                        pc.getSenders().forEach(sender => {
                            if (sender.track && !localStream.getTracks().includes(sender.track)) {
                                pc.removeTrack(sender);
                                console.log(`Removed old ${sender.track.kind} track from peer ${peerId}`);
                            }
                        });
                        // Add or replace tracks
                        localStream.getTracks().forEach(newTrack => {
                            let sender = pc.getSenders().find(s => s.track && s.track.kind === newTrack.kind);
                            if (sender) {
                                sender.replaceTrack(newTrack)
                                    .then(() => console.log(`Replaced ${newTrack.kind} track for ${peerId}`))
                                    .catch(e => console.error(`Error replacing track for ${peerId}:`, e));
                            } else {
                                // If a sender for this kind of track doesn't exist, add it
                                pc.addTrack(newTrack, localStream);
                                console.log(`Added new ${newTrack.kind} track to peer ${peerId}`);
                            }
                        });
                        // Renegotiate after track changes if needed (optional, but good for robust connections)
                        // If tracks were added/removed, this signals to the other peer to renegotiate
                        if (pc.signalingState !== 'stable') {
                             console.log(`Signaling state for ${peerId} is not stable, skipping renegotiation.`);
                             // If a negotiation is already in progress, avoid initiating another one immediately.
                             // A common pattern is to use a flag or queue for negotiation.
                        } else {
                            negotiateConnection(pc, peerId);
                        }
                    }
                }
                console.log('Local stream updated and tracks replaced in peer connections.');
                // Emit event for camera status change
                socket.emit('camera-status', { userId: socket.id, isCameraOn: cameraEnabled, isScreenSharing: sharingEnabled });
                showNotification(`Switched to ${type === 'camera' ? 'camera' : 'screen share'} stream.`, 'info');
            } catch (error) {
                console.error('Error accessing media devices:', error);
                let errorMessage = 'Could not access media devices. Please check permissions.';
                if (error.name === 'NotAllowedError') {
                    errorMessage = 'Access denied. Please grant permission for camera/mic/screen sharing.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = `No suitable device found for ${type} with specified settings.`;
                } else if (error.name === 'OverconstrainedError') {
                    errorMessage = `Constraints could not be satisfied for ${type}: ${error.constraint}`;
                } else if (error.name === 'AbortError') {
                    errorMessage = 'Device selection was cancelled.';
                }
                showNotification(errorMessage, 'error', 5000);
                updateMediaControlsState(false);
                localVideo.srcObject = null;
                localStream = null; // Ensure stream is null on failure
            }
        }
        async function updateCameraList() {
            cameraSelect.innerHTML = '<option value="">Select Camera</option>'; // Clear existing options
            const videoInputDevices = await navigator.mediaDevices.enumerateDevices().then(devices =>
                devices.filter(device => device.kind === 'videoinput')
            ).catch(err => {
                console.error('Error enumerating devices:', err);
                return [];
            });
            if (videoInputDevices.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No cameras found';
                cameraSelect.appendChild(option);
                cameraSelect.disabled = true; // Disable if no cameras
            } else {
                videoInputDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Camera ${cameraSelect.options.length + 1}`; // +1 for user-friendly numbering
                    cameraSelect.appendChild(option);
                });
                cameraSelect.disabled = false; // Enable if cameras are found
                // Select the currently active camera if available
                if (currentCameraDeviceId && Array.from(cameraSelect.options).some(opt => opt.value === currentCameraDeviceId)) {
                    cameraSelect.value = currentCameraDeviceId;
                } else if (localStream && localStream.getVideoTracks().length > 0) {
                    currentCameraDeviceId = localStream.getVideoTracks()[0].getSettings().deviceId;
                    if (Array.from(cameraSelect.options).some(opt => opt.value === currentCameraDeviceId)) {
                        cameraSelect.value = currentCameraDeviceId;
                    }
                } else if (videoInputDevices.length > 0) {
                    // Fallback: select the first camera if no current one is set
                    cameraSelect.value = videoInputDevices[0].deviceId;
                    currentCameraDeviceId = videoInputDevices[0].deviceId;
                }
            }
        }
        // Helper function to create or get a peer connection for a specific peer
        function createPeerConnection(peerId) {
            console.log(`Creating RTCPeerConnection for peer ID: ${peerId}`);
            const pc = new RTCPeerConnection(servers);
            peerConnections[peerId] = pc;
            // Add local stream tracks to the peer connection
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });
            }
            // Handle ICE candidates generation
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log(`Sending ICE candidate to ${peerId}`);
                    socket.emit('ice-candidate', { candidate: event.candidate, to: peerId });
                }
            };
            // Handle receiving remote media tracks
            pc.ontrack = (event) => {
                console.log('Remote track received:', event.streams[0]);
                let remoteVideo = document.getElementById(`remoteVideo-${peerId}`);
                if (!remoteVideo) {
                    remoteVideo = document.createElement('video');
                    remoteVideo.id = `remoteVideo-${peerId}`;
                    remoteVideo.autoplay = true;
                    remoteVideo.playsinline = true;
                    remoteVideosContainer.appendChild(remoteVideo);
                }
                remoteVideo.srcObject = event.streams[0];
            };
            // Handle peer connection closure
            pc.onconnectionstatechange = () => {
                console.log(`Connection state changed for peer ${peerId}: ${pc.connectionState}`);
                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {
                    removeRemoteVideo(peerId);
                    delete peerConnections[peerId];
                    if (dataChannels[peerId]) {
                        dataChannels[peerId].close();
                        delete dataChannels[peerId];
                    }
                    showNotification(`User ${peerId.substring(0, 4)}... disconnected.`, 'info');
                    updateMediaControlsState(!!localStream); // Update controls state
                }
            };
            // Handle data channel for chat and file sharing
            pc.ondatachannel = (event) => {
                const dataChannel = event.channel;
                dataChannels[peerId] = dataChannel;
                console.log(`Data channel '${dataChannel.label}' opened from peer ${peerId}`);
                dataChannel.onmessage = (e) => {
                    let message;
                    try {
                        message = JSON.parse(e.data);
                    } catch (error) {
                        console.error('Error parsing data channel message:', error);
                        return;
                    }
                    if (message.type === 'chat') {
                        addChatMessage(message.data, `User ${peerId.substring(0, 4)}`);
                        showNotification(`New message from ${peerId.substring(0, 4)}`, 'info', 2000);
                    } else if (message.type === 'file-start') {
                        // Prepare for file reception
                        const fileName = message.fileName;
                        const fileSize = message.fileSize;
                        receivedFiles[peerId] = {
                            fileName: fileName,
                            fileSize: fileSize,
                            data: [],
                            receivedSize: 0
                        };
                        fileStatusDiv.textContent = `Receiving file: ${fileName} (${(fileSize / (1024 * 1024)).toFixed(2)} MB)`;
                        showNotification(`Receiving file "${fileName}"`, 'info', 3000);
                    } else if (message.type === 'file-chunk') {
                        const fileInfo = receivedFiles[peerId];
                        if (fileInfo) {
                            // Data is sent as an array of numbers, convert back to Uint8Array
                            fileInfo.data.push(new Uint8Array(message.data));
                            fileInfo.receivedSize += message.data.length; // length of the array
                            const progress = (fileInfo.receivedSize / fileInfo.fileSize) * 100;
                            fileStatusDiv.textContent = `Receiving ${fileInfo.fileName}: ${progress.toFixed(2)}%`;
                        }
                    } else if (message.type === 'file-end') {
                        const fileInfo = receivedFiles[peerId];
                        if (fileInfo) {
                            const blob = new Blob(fileInfo.data);
                            const url = URL.createObjectURL(blob);
                            const listItem = document.createElement('li');
                            listItem.innerHTML = `<i class="fas fa-file-download"></i> <a href="${url}" download="${fileInfo.fileName}">${fileInfo.fileName}</a> (${(fileInfo.fileSize / 1024).toFixed(2)} KB)`;
                            receivedFilesList.appendChild(listItem);
                            fileStatusDiv.textContent = `File "${fileInfo.fileName}" received and ready for download.`;
                            showNotification(`File "${fileInfo.fileName}" received!`, 'success', 5000);
                            delete receivedFiles[peerId]; // Clean up
                        }
                    } else if (message.type === 'camera-status') {
                        // Handle remote user's camera/screen share status
                        const remoteVideoElement = document.getElementById(`remoteVideo-${peerId}`);
                        if (remoteVideoElement) {
                            // You can update UI elements associated with the remote video
                            // For example, display an icon for mic mute or camera off
                            console.log(`Peer ${peerId.substring(0,4)}... camera: ${message.isCameraOn}, screen sharing: ${message.isScreenSharing}`);
                            // Add a visual indicator on the remote video tile if desired
                            // Example: A small div with a 'camera off' icon
                        }
                    }
                };

                dataChannel.onopen = () => console.log(`Data channel with ${peerId} is open.`);
                dataChannel.onclose = () => console.log(`Data channel with ${peerId} is closed.`);
                dataChannel.onerror = (error) => console.error(`Data channel error with ${peerId}:`, error);
            };

            return pc;
        }
        function removeRemoteVideo(peerId) {
            const videoToRemove = document.getElementById(`remoteVideo-${peerId}`);
            if (videoToRemove) {
                remoteVideosContainer.removeChild(videoToRemove);
            }
        }
        // Function to initiate offer/answer exchange
        async function negotiateConnection(pc, peerId) {
            try {
                // If a negotiation is already in progress, or if the connection is not stable,
                // don't initiate a new one. This prevents "Too many negotiations" errors.
                if (pc.signalingState !== 'stable' && pc.localDescription) {
                    console.warn(`Skipping negotiation for ${peerId}, signalingState is ${pc.signalingState}`);
                    return;
                }
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                socket.emit('offer', { offer: offer, to: peerId });
                console.log(`Sent offer to ${peerId}`);
            } catch (error) {
                console.error(`Error creating or setting local description for ${peerId}:`, error);
                showNotification('Failed to initiate connection.', 'error');
            }
        }
        // Global variables for file sharing state
        let receivedFiles = {};
        const chunkSize = 16 * 1024; // 16 KB chunks
        // --- SIGNALING (Socket.IO Events) ---
        socket.on('connect', async () => {
            console.log('Connected to signaling server:', socket.id);
            // Replace 'default-room' with a dynamic room ID if needed
            const roomId = 'default-room'; // Or get from URL/user input
            socket.emit('join-room', roomId);
            showNotification(`Joined room: ${roomId}`, 'info');
            // Try to get local media stream on connect
            await getAndUpdateLocalStream('camera', currentCameraDeviceId || cameraSelect.value, resolutionSelect.value);
        });
        socket.on('all-users', async (users) => {
            console.log('Received all-users:', users);
            // Establish connections with existing users
            for (const peerId of users) {
                if (peerId === socket.id) continue; // Don't connect to self
                const pc = createPeerConnection(peerId);
                // Create a data channel *only if initiating the connection*
                // The receiver will handle `pc.ondatachannel`
                const chatDataChannel = pc.createDataChannel('chat');
                dataChannels[peerId] = chatDataChannel;
                chatDataChannel.onmessage = (e) => {
                    let message;
                    try {
                        message = JSON.parse(e.data);
                    } catch (error) {
                        console.error('Error parsing data channel message:', error);
                        return;
                    }
                    if (message.type === 'chat') {
                        addChatMessage(message.data, `User ${peerId.substring(0, 4)}`);
                        showNotification(`New message from ${peerId.substring(0, 4)}`, 'info', 2000);
                    } else if (message.type === 'file-start') {
                        const fileName = message.fileName;
                        const fileSize = message.fileSize;
                        receivedFiles[peerId] = {
                            fileName: fileName,
                            fileSize: fileSize,
                            data: [],
                            receivedSize: 0
                        };
                        fileStatusDiv.textContent = `Receiving file: ${fileName} (${(fileSize / (1024 * 1024)).toFixed(2)} MB)`;
                        showNotification(`Receiving file "${fileName}"`, 'info', 3000);
                    } else if (message.type === 'file-chunk') {
                        const fileInfo = receivedFiles[peerId];
                        if (fileInfo) {
                            fileInfo.data.push(new Uint8Array(message.data)); // Reconstruct Uint8Array from array
                            fileInfo.receivedSize += message.data.length;
                            const progress = (fileInfo.receivedSize / fileInfo.fileSize) * 100;
                            fileStatusDiv.textContent = `Receiving ${fileInfo.fileName}: ${progress.toFixed(2)}%`;
                        }
                    } else if (message.type === 'file-end') {
                        const fileInfo = receivedFiles[peerId];
                        if (fileInfo) {
                            const blob = new Blob(fileInfo.data);
                            const url = URL.createObjectURL(blob);
                            const listItem = document.createElement('li');
                            listItem.innerHTML = `<i class="fas fa-file-download"></i> <a href="${url}" download="${fileInfo.fileName}">${fileInfo.fileName}</a> (${(fileInfo.fileSize / 1024).toFixed(2)} KB)`;
                            receivedFilesList.appendChild(listItem);
                            fileStatusDiv.textContent = `File "${fileInfo.fileName}" received and ready for download.`;
                            showNotification(`File "${fileInfo.fileName}" received!`, 'success', 5000);
                            delete receivedFiles[peerId]; // Clean up
                        }
                    } else if (message.type === 'camera-status') {
                        const remoteVideo = document.getElementById(`remoteVideo-${peerId}`);
                        if (remoteVideo) {
                            console.log(`Peer ${peerId.substring(0,4)}... camera: ${message.isCameraOn}, screen sharing: ${message.isScreenSharing}`);
                        }
                    }
                };
                chatDataChannel.onopen = () => console.log(`Chat data channel with ${peerId} is open.`);
                chatDataChannel.onclose = () => console.log(`Chat data channel with ${peerId} is closed.`);
                chatDataChannel.onerror = (error) => console.error(`Chat data channel error with ${peerId}:`, error);
                await negotiateConnection(pc, peerId);
            }
        });
        socket.on('user-joined', async (peerId) => {
            console.log('User joined:', peerId);
            showNotification(`User ${peerId.substring(0, 4)}... joined.`, 'info');
            // Create a new peer connection for the newly joined user
            const pc = createPeerConnection(peerId);
            // We initiate the offer to the new user who just joined
            await negotiateConnection(pc, peerId);
        });
        socket.on('offer', async (data) => {
            console.log('Received offer from:', data.from);
            // Ensure we create/get the PC before setting remote description
            const pc = peerConnections[data.from] || createPeerConnection(data.from); 
            // Handle race condition: If an offer is received while we're already offering
            // or processing another offer, this might be a renegotiation.
            // A common pattern is to use a flag or queue, or just accept the new offer.
            // For simplicity here, we'll proceed.
            try {
                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                socket.emit('answer', { answer: answer, to: data.from });
                console.log(`Sent answer to ${data.from}`);
            } catch (error) {
                console.error(`Error handling offer from ${data.from}:`, error);
                // Handle potential errors like rollback if needed
            }
        });
        socket.on('answer', async (data) => {
            console.log('Received answer from:', data.from);
            const pc = peerConnections[data.from];
            if (pc) {
                try {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                } catch (error) {
                    console.error(`Error setting remote answer from ${data.from}:`, error);
                }
            } else {
                console.warn(`No peer connection found for ${data.from} to set answer.`);
            }
        });
        socket.on('ice-candidate', async (data) => {
            // console.log('Received ICE candidate from:', data.from); // Can be very chatty
            const pc = peerConnections[data.from];
            if (pc && data.candidate) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                } catch (e) {
                    // Ignore errors where candidate is already added or a negotiation is in progress
                    if (!e.message.includes('The ICE candidate has already been added')) {
                        console.error('Error adding received ICE candidate:', e);
                    }
                }
            }
        });
        socket.on('user-disconnected', (peerId) => {
            console.log('User disconnected:', peerId);
            showNotification(`User ${peerId.substring(0, 4)}... left the call.`, 'error');
            removeRemoteVideo(peerId);
            if (peerConnections[peerId]) {
                peerConnections[peerId].close();
                delete peerConnections[peerId];
            }
            if (dataChannels[peerId]) {
                dataChannels[peerId].close();
                delete dataChannels[peerId];
            }
            updateMediaControlsState(!!localStream); // Update controls state
        });
        // --- Event Listeners ---
        toggleMicButton.addEventListener('click', () => {
            if (localStream && localStream.getAudioTracks().length > 0) {
                micEnabled = !micEnabled;
                localStream.getAudioTracks()[0].enabled = micEnabled;
                updateMicrophoneIcon();
                showNotification(`Microphone ${micEnabled ? 'on' : 'off'}`, 'info', 1500);
                // Emit microphone status change (optional, but good for remote UI)
                socket.emit('mic-status', { userId: socket.id, isMicOn: micEnabled });
            } else if (!localStream) {
                showNotification('No active media stream to toggle microphone.', 'error');
            }
        });
        toggleCameraButton.addEventListener('click', async () => {
            // If currently sharing screen, toggle camera button behavior changes:
            // It tries to *stop* screen share and switch to camera.
            if (sharingEnabled) {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localVideo.srcObject = null;
                }
                sharingEnabled = false;
                updateScreenShareIcon(); // Reset screen share icon
                await getAndUpdateLocalStream('camera', currentCameraDeviceId || cameraSelect.value, resolutionSelect.value); // Switch back to camera
                showNotification('Stopped screen sharing and switched to camera.', 'info');
            } else if (localStream && localStream.getVideoTracks().length > 0) {
                // If camera is active, toggle it
                cameraEnabled = !cameraEnabled;
                localStream.getVideoTracks()[0].enabled = cameraEnabled;
                updateCameraIcon();
                showNotification(`Camera ${cameraEnabled ? 'on' : 'off'}`, 'info', 1500);
            } else {
                // If no camera stream (e.g., initially or after ending call), try to get camera
                await getAndUpdateLocalStream('camera', currentCameraDeviceId || cameraSelect.value, resolutionSelect.value);
            }
            // Always emit camera/sharing status after a change
            socket.emit('camera-status', { userId: socket.id, isCameraOn: cameraEnabled, isScreenSharing: sharingEnabled });
        });
        cameraSelect.addEventListener('change', async () => {
            const selectedDeviceId = cameraSelect.value;
            // Only update camera if not screen sharing
            if (selectedDeviceId && !sharingEnabled) {
                await getAndUpdateLocalStream('camera', selectedDeviceId, resolutionSelect.value);
            } else if (sharingEnabled) {
                showNotification('Cannot change camera while sharing screen.', 'info');
            }
        });
        resolutionSelect.addEventListener('change', async () => {
            const selectedResolution = resolutionSelect.value;
            // Only update resolution if not screen sharing
            if (!sharingEnabled) {
                await getAndUpdateLocalStream('camera', cameraSelect.value, selectedResolution);
            } else if (sharingEnabled) {
                showNotification('Cannot change resolution while sharing screen.', 'info');
            }
        });
        startShareButton.addEventListener('click', async () => {
            if (sharingEnabled) {
                // If currently sharing, stop sharing
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localVideo.srcObject = null;
                }
                sharingEnabled = false;
                updateScreenShareIcon();
                await getAndUpdateLocalStream('camera', currentCameraDeviceId || cameraSelect.value, resolutionSelect.value); // Switch back to camera
                showNotification('Stopped screen sharing.', 'info');
            } else {
                // If not sharing, start sharing
                await getAndUpdateLocalStream('screen');
                showNotification('Started screen sharing.', 'info');
            }
            socket.emit('camera-status', { userId: socket.id, isCameraOn: cameraEnabled, isScreenSharing: sharingEnabled });
        });
        toggleChatButton.addEventListener('click', () => {
            chatContainer.style.display = chatContainer.style.display === 'flex' ? 'none' : 'flex';
            if (fileShareContainer.style.display === 'block') { // Close file share if open
                fileShareContainer.style.display = 'none';
            }
        });
        shareFileButton.addEventListener('click', () => {
            fileShareContainer.style.display = fileShareContainer.style.display === 'block' ? 'none' : 'block';
            if (chatContainer.style.display === 'flex') { // Close chat if open
                chatContainer.style.display = 'none';
            }
        });
        sendButton.addEventListener('click', () => {
            const message = chatInput.value.trim();
            if (message) {
                addChatMessage(message); // Add to local chatbox
                // Send to all connected peers via data channel
                const connectedPeerIds = Object.keys(dataChannels);
                if (connectedPeerIds.length === 0) {
                    showNotification('No peers connected for chat.', 'error', 2000);
                }
                for (const peerId of connectedPeerIds) {
                    const dc = dataChannels[peerId];
                    if (dc && dc.readyState === 'open') {
                        dc.send(JSON.stringify({ type: 'chat', data: message }));
                    } else {
                        console.warn(`Data channel for ${peerId} not open, cannot send message.`);
                    }
                }
                chatInput.value = ''; // Clear input
            }
        });
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendButton.click();
            }
        });
        selectFileButton.addEventListener('click', () => {
            fileInput.click(); // Programmatically click the hidden file input
        });
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) {
                fileStatusDiv.textContent = 'No file selected.';
                return;
            }
            const connectedPeerIds = Object.keys(dataChannels);
            if (connectedPeerIds.length === 0) {
                fileStatusDiv.textContent = 'No peers connected to send file to.';
                showNotification('No active connections for file transfer.', 'error');
                return;
            }
            fileStatusDiv.textContent = `Preparing to send: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`;
            showNotification(`Sending file "${file.name}"...`, 'info', 5000);
            // Send file metadata to all peers
            for (const peerId of connectedPeerIds) {
                const dc = dataChannels[peerId];
                if (dc && dc.readyState === 'open') {
                    dc.send(JSON.stringify({
                        type: 'file-start',
                        fileName: file.name,
                        fileSize: file.size
                    }));
                }
            }
            const reader = new FileReader();
            let offset = 0;
            reader.onload = (event) => {
                const chunk = event.target.result; // ArrayBuffer
                // Send chunk to all peers
                for (const peerId of connectedPeerIds) {
                    const dc = dataChannels[peerId];
                    if (dc && dc.readyState === 'open') {
                        // Convert ArrayBuffer to a plain array of numbers (Uint8Array) for JSON stringify
                        // This is necessary because JSON.stringify doesn't handle ArrayBuffer directly
                        dc.send(JSON.stringify({
                            type: 'file-chunk',
                            data: Array.from(new Uint8Array(chunk))
                        }));
                    }
                }
                offset += chunk.byteLength;
                const progress = (offset / file.size) * 100;
                fileStatusDiv.textContent = `Sending ${file.name}: ${progress.toFixed(2)}%`;
                if (offset < file.size) {
                    readNextChunk();
                } else {
                    fileStatusDiv.textContent = `File "${file.name}" sent successfully!`;
                    showNotification(`File "${file.name}" sent!`, 'success');
                    // Send file-end signal to all peers
                    for (const peerId of connectedPeerIds) {
                        const dc = dataChannels[peerId];
                        if (dc && dc.readyState === 'open') {
                            dc.send(JSON.stringify({ type: 'file-end' }));
                        }
                    }
                    fileInput.value = ''; // Clear file input
                }
            };
            reader.onerror = (error) => {
                console.error('Error reading file:', error);
                fileStatusDiv.textContent = 'Error reading file.';
                showNotification('Error sending file.', 'error');
            };
            function readNextChunk() {
                const slice = file.slice(offset, offset + chunkSize);
                reader.readAsArrayBuffer(slice);
            }
            readNextChunk(); // Start reading the first chunk
        });
        toggleFullscreenButton.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                videoContainer.requestFullscreen().catch(err => {
                    alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        });
        endCallButton.addEventListener('click', () => {
            // Stop local tracks
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localVideo.srcObject = null;
                localStream = null;
            }
            // Close all peer connections
            for (const peerId in peerConnections) {
                if (peerConnections[peerId]) {
                    peerConnections[peerId].close();
                }
                delete peerConnections[peerId];
            }
            // Close all data channels
            for (const peerId in dataChannels) {
                if (dataChannels[peerId]) {
                    dataChannels[peerId].close();
                }
                delete dataChannels[peerId];
            }
            // Remove all remote videos
            remoteVideosContainer.innerHTML = '';
            // Emit a disconnect signal to the server (optional, but good practice)
            // It will be handled by the server's 'disconnect' event.
            socket.disconnect(); // This will also cause the 'disconnect' event to fire on the server
            // Reconnect the socket for future use without page refresh
            setTimeout(() => { // Give a moment for disconnect to process on server
                socket.connect();
            }, 1000);
            // Reset UI state
            micEnabled = true;
            cameraEnabled = true;
            sharingEnabled = false;
            updateMicrophoneIcon();
            updateCameraIcon();
            updateScreenShareIcon();
            updateMediaControlsState(false);
            chatContainer.style.display = 'none';
            fileShareContainer.style.display = 'none';
            chatBox.innerHTML = '<p>Welcome to the chat!</p>';
            receivedFilesList.innerHTML = '';
            fileStatusDiv.textContent = '';

            showNotification('You have left the call.', 'info');
        });
        // Initialize on page load
        updateMediaControlsState(false); // Initially no active stream
        updateMicrophoneIcon(); // Set initial mic icon state
        updateCameraIcon(); // Set initial camera icon state
        updateScreenShareIcon(); // Set initial screen share icon state
        updateCameraList(); // Populate camera list on load (requires permission, may initially be empty labels)
    </script>
</body>
</html>